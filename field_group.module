<?php
/**
 * @file
 * Allows administrators to attach custom fields to fieldable types.
 */

// namespace Drupal\field_group;
// use Drupal\field_group\Plugin\Core\Entity;
use Drupal\Component\Uuid\Uuid;
// use Drupal\field_group\Plugin\field\widget\TestWidget;
// use Drupal\field_group\Plugin\Core\Entity\FieldGroup;
use Drupal\field_group\FieldGroup;
// use Drupal\field_group\Plugin\field_group\Div;
use Drupal\field_group\FieldGroupAddGroup;
use Drupal\field_group\FieldGroupFieldUi;

use Drupal\Core\Template\Attribute;

// use Drupal\field_group\Plugin\FieldGroupPluginManager;

use Drupal\Core\Entity\EntityManager;


function field_group_form_alter(&$form, &$form_state, $form_id) {
  // dsm($form);
  // dsm($form['fields']['field_image']['settings_edit']);
  // print'<pre>';print_r($form['fields']['field_image']['settings_edit']);print'</pre>';
}


// MANAGE DISPLAY: field_ui_display_overview_form
function field_group_form_field_ui_display_overview_form_alter(&$form, &$form_state, $form_id) {
  field_group_admin_form($form, $form_state, $form_id);
}
// FORM MANAGE DISPLAY: field_ui_form_display_overview_form
function field_group_form_field_ui_form_display_overview_form_alter(&$form, &$form_state, $form_id) {
  field_group_admin_form($form, $form_state, $form_id);
}

function field_group_admin_form(&$form, &$form_state, $form_id) {

  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $display_mode = ($form_id == 'field_ui_display_overview_form') ? 'view' : FALSE;
  $display_mode = ($form_id == 'field_ui_form_display_overview_form') ? 'form' : $display_mode;
  $view_mode = $form['#mode'];




  $storage_controller = \Drupal::entityManager()->getStorageController('field_group');
  $field_group_field_ui = new FieldGroupFieldUi($storage_controller);
  $fields = array(
    'fields' => $form['#fields'],
    'extra' => $form['#extra']
  );
  $field_group_field_ui->setFormData($fields, $entity_type, $bundle, $display_mode, $view_mode);

  // Get existing fieldgroups.
  $field_group = new FieldGroup($entity_type, $bundle, $display_mode, $view_mode);
  $existing_field_groups = $field_group->getFieldGroups();


  $add_group = new FieldGroupAddGroup();
  $form['fields']['_add_new_field_group'] = $add_group->field_group_add_group();


  $machine_names = $field_group_field_ui->getMachineNames();
  $draggable_fields = $field_group_field_ui->getDraggableFields();

  // // dsm($form['fields']['field_image']['settings_edit']);
  foreach($field_group->getFieldgroupInstance($machine_names) as $group_name => $group) {
    $form['#fields'][] = $group_name;
    $form['fields'][$group_name] = $group;
    $form['fields'][$group_name]['settings_edit'] = array(
      '#submit' => array(
        array($form_state['build_info']['callback_object'], 'multistepSubmit'),
        // array($field_group_field_ui, 'multistepSubmit'),
      ),
      '#ajax' => array(
        'callback' => array($form_state['build_info']['callback_object'], 'multistepAjax'),
        // 'callback' => array($field_group_field_ui, 'multistepAjax'),
        'wrapper' => 'field-display-overview-wrapper',
        'effect' => 'fade',
      ),
      '#field_name' => $group_name, // 'field_group-' + $group_name, //'field_test',
      '#type' => 'image_button',
      '#name' => 'field_image_settings_edit',
      '#src' => 'core/misc/configure-dark.png',
      '#attributes' => array(
        'class' => array(
          0 => 'field-plugin-settings-edit',
        ),
        'alt' => 'Edit',
      ),
      '#op' => 'edit',
      '#limit_validation_errors' => array(
        0 => array(
          0 => 'fields',
          1 => $group_name,
          2 => 'type'
        )
      ),
      '#prefix' => '<div class="field-plugin-settings-edit-wrapper">',
      '#suffix' => '</div>'
    );
    // dsm($form['fields'][$group_name]);
  }

  // TODO: THis needs to be generic. Looks like a huge amount of work -.-"
  if($form_state['plugin_settings_edit'] == 'field_group_what_about_that') {
    $insance = Drupal::service('plugin.manager.field_group')->createInstance('fieldset');
    $settings_form = $insance->settingsForm($form, $form_state);
    unset($form['fields']['field_group_what_about_that']['plugin']['type']);
    // $form['fields']['field_group_what_about_that']['plugin']['settings_edit_form'] = $settings;


    $field_id = 'field_group_what_about_that';
    // Base button element for the various plugin settings actions.
    $base_button = array(
      '#submit' => array(array($form_state['build_info']['callback_object'], 'multistepSubmit')),
      '#ajax' => array(
        'callback' => array($form_state['build_info']['callback_object'], 'multistepAjax'),
        'wrapper' => 'field-display-overview-wrapper',
        'effect' => 'fade',
      ),
      '#field_name' => $field_id,
    );

    $form['fields']['field_group_what_about_that']['plugin']['settings_edit_form'] += array(
      '#type' => 'container',
      '#attributes' => array('class' => array('field-plugin-settings-edit-form')),
      '#parents' => array('fields', $field_id, 'settings_edit_form'),
      'label' => array(
        '#markup' => t('Plugin settings'),
      ),
      'settings' => $settings_form,
      'actions' => array(
        '#type' => 'actions',
        'save_settings' => $base_button + array(
          '#type' => 'submit',
          '#name' => $field_id . '_plugin_settings_update',
          '#value' => t('Update'),
          '#op' => 'update',
        ),
        'cancel_settings' => $base_button + array(
          '#type' => 'submit',
          '#name' => $field_id . '_plugin_settings_cancel',
          '#value' => t('Cancel'),
          '#op' => 'cancel',
          // Do not check errors for the 'Cancel' button, but make sure we
          // get the value of the 'plugin type' select.
          '#limit_validation_errors' => array(array('fields', $field_id, 'type')),
        ),
      ),
    );
    $form['fields']['field_group_what_about_that']['plugin']['#cell_attributes'] = array(
      'colspan' => 3,
    );
    unset($form['fields']['field_group_what_about_that']['settings_edit']);
    unset($form['fields']['field_group_what_about_that']['settings_summary']);
  }

  // dsm($form);
  // dsm($form_state);

  // dsm($form['fields']['field_group_test']);
  dsm($form['fields']['field_test']);
  dsm($form['fields']['field_test']['plugin']['settings_edit_form']);
  // dsm($form['fields']['field_image']);
  // dsm($form['fields']['field_summary']);

  // Add the parent parameters.
  // TODO: This may needs to be refactored.
  foreach($existing_field_groups as $id => $id) {
    $field_parent = config('field_group.' . $id)->get('machine_name');
    $fields = config('field_group.' . $id)->get('fields');
    if(!empty($fields)) {
      foreach ($fields as $field_name => $field_name) {
        if($field_name != $field_parent) {
          $form['fields'][$field_name]['parent_wrapper']['parent']['#value'] = $field_parent;
        }
      }
    }
  }

  // Prepare options to make them draggable to field_groups.
  $options = array();
  $option = $field_group->getFieldgroupInstance($machine_names);
  $option = (array) array_keys($option);
  foreach($option as $delta => $key) {
    $options[$key] = $key;
  }
  // Add _add_new_field_group to options, to be able to nest fields on-the-flow.
  $options['_add_new_field_group'] = '_add_new_field_group';
  // Add options to the fields.
  foreach($draggable_fields as $field_name) {
    if(isset($form['fields'][$field_name])) {
      $form['fields'][$field_name]['parent_wrapper']['parent']['#options'] = $options;
    }
  }

  // We need to add _add_new_field_group to the regions array, otherwise it won't be displayed.
  $form['fields']['#regions']['hidden']['rows_order'][] = '_add_new_field_group';

  // Use custom submit function.
  // TODO: The submit function is storing the field_groups and may need to be added to
  //       the FieldGroup class instead of the UI class.
  $form['#submit'][] = array($field_group_field_ui, 'submitForm');
}


/**
 * Render API callback: Checks if a field machine name is taken.
 *
 * @param $value
 *   The machine name, not prefixed with 'field_group_'.
 *
 * @return
 *   Whether or not the field machine name is taken.
 */
function _field_group_field_name_exists($value) {
  // Prefix with 'field_'.
  $field_name = 'field_group_' . $value;

  $exists = Drupal::entityQuery('field_group')
   ->condition('machine_name', $value)
   ->execute();
   // TODO: This is not working yet.
  if(!empty($exists)) {
    return TRUE;
  }
  return FALSE;
}


function field_group_field_overview_row_region($row) {
  // dsm($row['#row_type']);
  switch ($row['#row_type']) {
    case 'field_group':
      return 'content';
    case 'feld_group2':
  }
}


// TODO: Get groups by entity/bundle/form:display/
// TODO: Merge this into field_Group class, this is pretty messy! Shame on me.
function field_group_get_field_groups($entity_type, $bundle, $view_mode) {

  $id = $entity_type . '.' . $bundle . '.' . $view_mode;
  $field_groups = Drupal::entityQuery('field_group')
   ->condition('entity_type', $entity_type)
   ->condition('bundle', $bundle)
   ->condition('mode', $view_mode)
   ->execute();
   // dsm($field_groups);

  if(isset($field_groups)) {
    $groups = $field_groups;
  }
  else {
    $groups = array();
  }
  $field_groups = array();
  // foreach(element_children($groups) as $delta => $group_name) {
  //   $field_groups[$group_name] = $group_name;
  // }
  $field_groups = $groups;
  return $field_groups;
}


function field_group_get_field_groups_keys($entity_type, $bundle, $view_mode, $filter = FALSE) {
  $groups = field_group_get_field_groups($entity_type, $bundle, $view_mode);
  if(isset($filter)) {
    unset($groups[$filter]);
  }
  return $groups;
}


function field_group_field_group_format_settings() {
  dsm('field_group_field_group_format_settings');
  dsm(get_defined_vars());
}





function field_group_entity_view(\Drupal\Core\Entity\EntityInterface $entity, \Drupal\entity\Plugin\Core\Entity\EntityDisplay $display, $view_mode, $langcode) {
  // Only do the extra work if the component is configured to be displayed.
  // This assumes a 'mymodule_addition' extra field has been defined for the
  // entity bundle in hook_field_extra_fields().
  // dsm($display);
  if ($display->getComponent('mymodule_addition')) {
    $entity->content['mymodule_addition'] = array(
      '#markup' => mymodule_addition($entity),
      '#theme' => 'mymodule_my_additional_field',
    );
  }
}

function field_group_entity_view_alter(&$build, Drupal\Core\Entity\EntityInterface $entity, \Drupal\entity\Plugin\Core\Entity\EntityDisplay $display) {
  // Attach groups to entity_view.
  field_group_attach_groups($build, $entity, $display);
  // dsm($build);


  // dsm($entity);
  // dsm($display);
}

// TODO: Put output into fieldgroups here!
function field_group_attach_groups(&$build, $entity, $display) {
  // dsm('field_group_attach_groups');
  // dvm($display->mode);
  // dsm(field_group_get_field_groups($entity->entityType(), $entity->bundle(), $display->mode));
  // dsm($build);

  // TODO: This should be the right view mode ;)
  $form = array();

  $entity_type = $display->targetEntityType;
  $bundle = $display->bundle;
  $display_mode = 'view';
  $view_mode = $display->mode;


  $field_group = new FieldGroup($entity_type, $bundle, $display_mode, $view_mode);
  $existing_field_groups = $field_group->getFieldGroups();

  // dsm(config(reset($existing_field_groups)));

  // WRAP FIELDS INTO FIELDGROUPS!!
  foreach ($existing_field_groups as $key => $key) {
    $widget_type = config('field_group.' . $key)->get('widget_type');
    $fields = config('field_group.' . $key)->get('fields');
    $machine_name = config('field_group.' . $key)->get('machine_name');
    $children = array();
    $build[$machine_name] = array(
      '#type' => 'field_group',
      '#widget' => $widget_type,
    );
    if(!empty($fields)) {
      foreach ($fields as $field_name => $field_name) {
        if(isset($build[$field_name])) {
          $build[$machine_name][$field_name] = $build[$field_name];
          unset($build[$field_name]);
        }
      }
    }

  }
}


function template_preprocess_field_group__div(&$variables) {
  // TODO: We'll see, perheps nothing.
}
function template_preprocess_field_group__fieldset(&$variables) {
  // TODO: We'll see, perheps nothing.
}

function theme_field_group(&$variables) {
  $element = $variables['element'];
  $variables += array(
    'children' => $element['#children']
  );
  return theme('field_group__' . $element['#widget'], $variables);
}

function field_group_theme() {
  return array(
    'field_group' => array(
      'render element' => 'element',
    ),
    // TODO: Generate theme function for each widget plugin.
    'field_group__div' => array(
      'render element' => 'element',
      'template' => 'field-group--div',
    ),
    'field_group__fieldset' => array(
      'render element' => 'element',
      'template' => 'field-group--fieldset',
    ),
  );
}

function field_group_widget_options() {
  $widget_options = array();

  $widgets = drupal_container()->get('plugin.manager.field_group')->getDefinitions();
  foreach($widgets as $widget_name => $widget) {
    $field_type = key(array_flip($widget['field_types']));
    if($field_type == 'field_group') {
      $widget_options[$widget_name] = $widget_name;
    }
  }
  return $widget_options;
}



/**
 * Implementation of hook_element_info().
 */
function field_group_element_info() {
  $types = array();
  $types['field_group'] = array(
    '#theme_wrappers' => array('field_group'),
  );

  return $types;
}


